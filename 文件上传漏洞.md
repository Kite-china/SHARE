# ::$DATA绕过

属于Windows本地文件系统中的文件流（File Streams）:当从Windows shell命令行指定创建文件时，流的完整名称为“***filename:stream name:stream type***”，例如：“**myfile.txt:stream1:$DATA**”

# %00截断

事实上0x00，%00这两类截断都是属于同种原理，%00在url解码后为空字符，0X00即16进制的00，只是表示和用法不同而已
无论0x00还是%00，最终被解析后都是一个东西:chr（0）

chr()是一个函数，这个函数是用来返回参数所对应的字符的，也就是说，参数是一个ASCII码，返回的值是一个字符，类型为string。

那么chr(0)就很好理解了，对照ASCII码表可以知道，ASCII码为0-127的数字，每个数字对应一个字符，而0对应的就是NUT字符（NULL），也就是空字符，而截断的关键就是这个空字符，当一个字符串中存在空字符的时候，在被解析的时候会导致空字符后面的字符被丢弃。

举例说明：
当我们在GET场景上传一个名为eval.php%00.jpg的文件，后台程序收到此文件后，开始检测其名称，当检测到%00后产生截断，不再继续解析%00之后的内容。于是，系统上存储的实际为eval.php。

如何利用%00以及0x00截断：
1.php版本要小于5.3.29(有说<5.3.4即可，但我亲测5.3.29无法实现)，以上版本已经修复该问题

2.magic_quotes_gpc需要为OFF状态
当打开magic_quotes_gpc时，所有的 '（单引号），"（双引号），\（反斜线）和 NULL字符（%00）都会被自动加上一个反斜杠进行转义。

3.文件路径可控（即本关卡），比如我可以修改路径拼接的path时，比如抓到的包中存在path: uploads/，就可以直接把路径构造成uploads/xxx.php%00，先构造一个存在截断字符的后缀“等着”真正的文件名，或者后缀名，因为不管它是啥，都会被截断而丢弃

一般来说，在GET传参时，由于url中的内容会进行url编码，而%00在经过解码之后便是空字符导致截断。
而在在POST传参时， POST 中 %00 不会被 url 解码，所以只能通过 burpsuite 修改 hex 值为 00 进行截断
————————————————
版权声明：本文为CSDN博主「skynet_x」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/skynet_x/article/details/109285482
